// https://tools.ietf.org/id/draft-whited-kitten-password-storage-03.html
import dotenv from 'dotenv';
import bcrypt from 'bcrypt'; // https://www.npmjs.com/package/bcrypt
import CryptographyError from '../errors/CryptographyError';

const dotenvResult = dotenv.config();
if(dotenvResult.error && process.env.NODE_ENV !== 'production') throw dotenvResult.error;

const saltRounds = 10;
const isDebug = process.env.LOGGER_LEVEL === 'trace' || process.env.LOGGER_LEVEL === 'debug';

/**
 * Responsible for salting and hashing a provided password.
 *
 * @param  {String}  hashword Already lightly hashed for communication over https protocol.
 *
 * @return {Promise}          The promise resolves with a hashed String to be stored; rejects with CryptographyError.
 */
export const saltAndHash = hashword => {
	return bcrypt.hash(hashword, saltRounds).catch(
		e => {
			if(isDebug){
				e.message += `; saltAndHash() received hashword=${hashword}.`;
				throw e;
			}else throw new CryptographyError('The contents of the error are hidden for security reasons.');
		}
	);
};

/**
 * Responsible for comparing a provided password with a master password.
 *
 * @param  {String}  hashword Already lightly hashed for communication over https protocol.
 * @param  {String}  stored   This was previously generated by saltAndHash and then stored for future authentication tests.
 *
 * @return {Promise}          The promise resolves with a Boolean response; rejects with CryptographyError.
 */
export const isMatch = (hashword, stored) => {
	return bcrypt.compare(hashword, stored).catch(
		e => {
			if(isDebug){
				e.message += `; isMatch() received hashword=${hashword} and stored=${stored}.`;
				throw e;
			}else throw new CryptographyError('The contents of the error are hidden for security reasons.');
		}
	);
};

/**
 * Responsible for a very basic test run of saltAndHash and isMatch.
 *
 * @return {Promise} The promise should resolve with TRUE; try to catch errors.
 */
export const selfTest = () => {
	const password = 'ed809121b93e4ecab38659e77f5aa3ad';
	let stored;
	return saltAndHash(password).then(
		saltedAndHashed => stored = saltedAndHashed
	).then(
		() => isMatch(password, stored)
	);
};